
pnpm 9.x后 link-workspace-packages改为了默认为 false，需要新建.npmrc文件，添加link-workspace-packages=true，在安装依赖时优先在本地链接，而不是从 registry（远程） 中下载


## 组件库开发三要素
- 用 monorepo 管理多种类型组件库，这类项目的代码管理方式，可以一个仓库同时聚合管
理多个项目，让项目之间代码依赖使用更方便；
- 源码要编译成多种模块格式（CommonJS 和 ES Module），主要考虑到前端代码 npm 模
块的时候，目前主流是 ES Module 模块格式，但还是存在很多传统的 CommonJS 模块格
式的使用兼容。所以在开发自研组件库的时候，尽量要考虑这两种模块格式；
- 基于 Less 等预处理 CSS 语言来开发组件库的样式，由于 CSS 语言能力有限，无法像
JavaScript 那样可以使用各种编程逻辑和特性，所以需要借助 CSS 预处理语言进行开发
CSS。


## 组件库的主题方案

- 梳理组件库用到的基本颜色和对应的颜色梯度，用 Less 或其他 CSS 预处理器语言来编
写；
- 每个组件通过 CSS Variable 来控制各种语义化颜色，例如按钮的背景颜色；
- 主题控制是利用 CSS Varibale 来修改覆盖每个组件里语义化的“颜色”和“梯度号”。

## 动态渲染组件

### 特点
- 以直接函数式地使用来执行渲染，使用者不需要写代码来挂载组件；
- 组件内部实现了动态挂载和卸载节点的操作。

### Vue.js 3.x 动态渲染组件在页面上是独立于“Vue.js 主应用”之外的渲染。
动态渲染组件，在项目应用里，只是调用组件的函数（或者方法），然后创建一个独立
于“Vue.js 主应用”外的一个“Vue.js 副应用”，动态挂载（mount）在 HTML 动态创建的 DOM
上。如果要关闭动态渲染组件，就需要再次触发一个关闭函数（或者方法），把这个“Vue.js
的副应用”卸载（unmount），最后把动态创建的 DOM 也一并销毁回收。这样，就完成动态渲
染组件从挂载到卸载的一个完整的生命周期。

### 消息提醒组件（Message）和对话框组件 (Dialog)
### 实现思路
第一步：设计动态渲染组件的使用函数方法的 API，API 越简洁越好，核心是要控制组件渲
染的挂载和卸载的生命周期；
第二步：基于 Vue.js 3.x 实现动态渲染组件的原理，核心是要在页面上动态创建 DOM，再
用 Vue.js 3.x 创建一个独立应用来“承载”这个组件，挂载在这个动态 DOM 上面；
第三步：关闭动态组件时，要卸载这个 Vue.js 3.x 的“独立应用”，卸载完再销毁这个动态
DOM。

### 注意
在组件的挂载和卸载过程中，尽量用 Vue.js 3.x 的内置 <transition> 组件来实现动画过渡效
果，提升用户体验，减少组件动态显示和消失的突兀感觉。
动态组件在关闭后，注意要记得销毁组件挂载的动态 DOM，释放没必要的内存占用，减少
内存泄漏的风险。

## 布局组件

### 布局规范设计的三个准备点：

- 栅格化系统的设计；
- 不同布局组件的语义化定义；
- 根据栅格组件和语义布局组件，组合实现各种页面布局。

## 受控表单组件

“受控组件”就是通过内置统一状态或者数据管理来控制表单操作，而“非受控
组件”就是使用原生 HTML 的表单特性来实现表操作

## 动态表单组件

定义表单数据组件的统一 API；
定义默认支持的数据表单组件；
支持自定义表单字段的校验规则；
支持根据统一 API 扩展自定义表单数据组件。

## 代码单元测试

vitest， 是 Vitest 测试工具核心模块，提供了单元测试管理和断言等工具；
@vue/test-utils，是 Vue.js 测试工具，辅助处理 Vue.js 在 Node.js 环境里操作 DOM 渲染
和 DOM 事件等操作；
@vitejs/plugin-vue，是 Vitest 的插件，支持直接构建运行 Vue.js 模板代码；
@vitejs/plugin-vue-jsx，是 Vitest 的插件，支持直接构建运行 Vue.js 的 JSX 代码；
jsdom，用来在 Node.js 环境中模拟浏览器的原生 API，例如操作 DOM 的原生 API 等。


渲染测试场景，验证 Vue.js 组件代码最终 DOM 是否符合预期；
行为测试场景，验证用户操作 Vue.js 组件后最终变化是否符合预期；
请求测试场景，用模拟操作方式，验证组件里数据请求逻辑是否符合预期；
兜底测试场景，用传统 Vue.js 渲染方式，间接验证组件功能是否符合预期。

### 局限性
- 前端的单元测试，只能通过“数据”形式来保证测试结果和测试断言，无法验证最终渲染的视觉
效果。而且，目前大多数前端单元测试都是在 Node.js 环境里进行的，跟实际浏览器还是存在
差异。如果要验证最终视觉效果，我们就要用到 E2E 测试，也就是“End to End”的端对端测
试，你可以选择使用 Cypress 这个 E2E 测试工具。
- 此外，单元测试还有另一个局限性，在频繁变更功能的需求场景下，每次变更功能，我们都必
须重写测试用例，这样时间成本会大大增加。所以，单元测试等这些测试操作，大多数用于比
较稳定的代码，例如我们举例的组件库代码。当然了，这个局限性也不仅仅局限于单元测试，
E2E 测试等测试操作都有。


## 定制拖拽运营组件

### 如何实现简单的拖拽布局功能
1. 定义父容器和子模块；
2. 监听子模块的拖拽开始事件；
3. 监听拖拽过程经过父容器里哪些子模块；
4. 计算和重新渲染拖拽过程的临时布局；
5. 监听拖拽结束事件，更新最终模块布局。

### Vue3 封装拖拽布局的业务组件